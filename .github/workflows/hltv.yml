name: HLTV projections (no CSV — names only)

on:
  workflow_dispatch:
    inputs:
      player_list:
        description: "Comma-separated player names (leave blank to use ALIASES keys)"
        required: false
        default: ""
      lookback_days:
        description: "HLTV player stats lookback window (days)"
        required: false
        default: "60"
      throttle_ms:
        description: "Delay between HLTV requests (ms)"
        required: false
        default: "350"

jobs:
  run:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install deps
        run: npm i hltv papaparse

      - name: Project from player names only (ALIASES + fuzzy + HLTV search)
        env:
          PLAYER_LIST: ${{ inputs.player_list }}
          LOOKBACK_DAYS: ${{ inputs.lookback_days }}
          THROTTLE_MS: ${{ inputs.throttle_ms }}
        run: |
          node - <<'JS'
          const { HLTV } = require('hltv');
          const fs = require('fs');
          const Papa = require('papaparse');

          const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
          const UA = 'Mozilla/5.0 (compatible; HLTV-NamesOnly/1.0; +github-actions)';
          const norm = s => String(s||'')
            .toLowerCase()
            .normalize('NFKD').replace(/[\u0300-\u036f]/g,'')
            .replace(/\s+/g,'')
            .replace(/[^a-z0-9_]/g,'');

          // ======= YOUR ALIASES (fixed) =======
          const ALIASES = {
            "adron": null, "aw": null, "artfr0st": null, "belchonokk": null, "batuuu": null,
            "brollan": null, "clasia": null, "cypher": null, "callme": null, "chop": null,
            "chopper": null, "ciocardau": null, "closer": null, "crunchy": null, "cryptic": null,
            "dgl": null, "dengzoe": null, "drox": null, "elfmelk": null, "fallen": null,
            "grizz": null, "heavygod": null, "hext": null, "icarus": null, "jambo": null,
            "jame": null, "jayy2s": null, "jimpphat": null, "johnsm1th": null, "junior": null,
            "krimz": null, "kscerato": null,
            "karrigan": 429,
            "spinx": 16949,
            "sunpayus": 15858,
            "zywoo": 11893,
            "blamef": 15165,
            "broky": 16555,
            "donk": 22729,
            "flamez": 20102,
            "frozen": 7187,
            "hunter": 9647,
            "rain": 8183,
            "ropz": 11816,
            "torzsi": 19619,
            "xertion": 20424
          };

          // ======= utils =======
          function erf(x){const s=x<0?-1:1;x=Math.abs(x);const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;const t=1/(1+p*x);const y=1-(((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t)*Math.exp(-x*x);return s*y;}
          const shrink = (rate,n,base,k)=>((n*rate+k*base)/((n+k)||1));
          const writeCSV = (rows, path) => { try { fs.writeFileSync(path, Papa.unparse(rows||[],{quotes:true})); } catch { fs.writeFileSync(path,''); } };
          async function withRetry(fn, {tries=3, delay=800}={}){ let last; for (let i=0;i<tries;i++){ try { return await fn(); } catch(e){ last=e; await sleep(delay); } } throw last; }

          function extractPlayerIds(html){
            const re=/\/player\/(\d+)\/[a-z0-9-]+/ig; let m; const out=new Set();
            while((m=re.exec(html))!==null){ out.add(parseInt(m[1],10)); if(out.size>=5) break; }
            return [...out];
          }
          async function hltvSearchByName(name){
            const q=encodeURIComponent(String(name||'').trim());
            const urls=[
              `https://www.hltv.org/stats/players?search=${q}`,
              `https://www.hltv.org/search?query=${q}`
            ];
            for(const url of urls){
              try{
                const res=await withRetry(()=>fetch(url,{headers:{'user-agent':UA}}));
                if(!res.ok) continue;
                const html=await res.text();
                const ids=extractPlayerIds(html);
                if(ids.length) return ids[0];
              }catch(e){}
              await sleep(400);
            }
            return null;
          }

          (async ()=>{
            const LOOKBACK_DAYS = parseInt(process.env.LOOKBACK_DAYS||'60',10);
            const THROTTLE_MS   = parseInt(process.env.THROTTLE_MS||'350',10);

            // Build target player list:
            const input = (process.env.PLAYER_LIST||'').trim();
            let players = input
              ? input.split(',').map(s=>s.trim()).filter(Boolean)
              : Object.keys(ALIASES); // default: all ALIASES keys
            // de-dup & keep readable names for output
            players = [...new Set(players)];

            // Map to HLTV ids: ALIASES → live search
            const mapped=[], unresolved=[];
            for(const name of players){
              const key=norm(name);
              let id = Number.isFinite(+ALIASES[key]) ? +ALIASES[key] : null;
              if(!id){
                id = await hltvSearchByName(name);
                await sleep(250);
              }
              if(id) mapped.push({ name, hltv_id:id, source: Number.isFinite(+ALIASES[key])?'alias':'search' });
              else unresolved.push({ name });
              await sleep(THROTTLE_MS);
            }

            // Pull stats
            const today = new Date();
            const startDate = new Date(today.getTime() - LOOKBACK_DAYS*86400000).toISOString().slice(0,10);
            const endDate   = today.toISOString().slice(0,10);

            const stats=[];
            for(const m of mapped){
              try{
                const s = await withRetry(()=>HLTV.getPlayerStats({ id:m.hltv_id, startDate, endDate }), {tries:3, delay:900});
                stats.push({
                  playerId:m.hltv_id, source:m.source,
                  nickname:s?.player?.nickname || m.name,
                  realname:s?.player?.name || '',
                  team:s?.team?.name || '',
                  maps:s?.overview?.mapsPlayed,
                  kpr:s?.overview?.kpr,
                  hsPct:s?.overview?.hsPercentage,
                  adr:s?.overview?.adr,
                  rating:s?.overview?.rating1
                });
              }catch(e){
                stats.push({ playerId:m.hltv_id, nickname:m.name, team:'', maps:0, kpr:'', hsPct:'', adr:'', rating:'', source:m.source, error:e.message });
              }
              await sleep(THROTTLE_MS);
            }

            // Conservative projections (no opponent context)
            const leagueKPR=0.68, leagueHS=0.46, EXPECTED_ROUNDS=50;
            const projections=[];
            for(const r of stats){
              const maps=+r.maps||0;
              const kpr =+r.kpr || leagueKPR;
              const hs  =+r.hsPct|| leagueHS;
              const kprAdj=shrink(kpr,maps,leagueKPR,maps<25?40:25);
              const hsAdj =shrink(hs, maps,leagueHS, maps<25?60:40);
              const muKills=EXPECTED_ROUNDS*kprAdj;
              projections.push({
                player:r.nickname, team:r.team, maps,
                kprAdj:+kprAdj.toFixed(3), hsAdj:+hsAdj.toFixed(3),
                projKills:+muKills.toFixed(1), projHS:+(muKills*hsAdj).toFixed(1),
                rating:r.rating||'', adr:r.adr||'', id:r.playerId, id_source:r.source
              });
            }

            // Outputs
            const mappedOut = mapped.map(x=>({player:x.name, hltv_id:x.hltv_id, source:x.source}));
            writeCSV(mappedOut, 'names_mapped.csv');
            writeCSV(unresolved, 'names_unresolved.csv');
            writeCSV(stats, 'hltv_player_form.csv');
            writeCSV(projections, 'hltv_projections.csv');

            // Also create a helper template you can fill with book lines later:
            const tmpl = projections.map(p=>({
              player:p.player,
              market_example:'kills_on_maps_1_2',
              our_proj:p.projKills
            }));
            writeCSV(tmpl, 'edges_template_fill_lines.csv');

            console.log(`Done. Names in: ${players.length}, mapped: ${mapped.length}, unresolved: ${unresolved.length}, projections: ${projections.length}`);
          })().catch(e=>{
            console.error('Top-level error:', e?.message);
            try{ fs.writeFileSync('hltv_projections.csv',''); }catch{}
            try{ fs.writeFileSync('hltv_player_form.csv',''); }catch{}
            try{ fs.writeFileSync('names_mapped.csv',''); }catch{}
            try{ fs.writeFileSync('names_unresolved.csv',''); }catch{}
            try{ fs.writeFileSync('edges_template_fill_lines.csv',''); }catch{}
            process.exitCode=0;
          });
          JS

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: hltv_names_only_outputs
          path: |
            names_mapped.csv
            names_unresolved.csv
            hltv_player_form.csv
            hltv_projections.csv
            edges_template_fill_lines.csv
          if-no-files-found: warn
