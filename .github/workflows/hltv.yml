name: HLTV Top-100 ingest + projections
on:
  workflow_dispatch: {}

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install deps
        run: npm i hltv papaparse

      - name: Fetch HLTV Top-100 → rosters → player stats → projections (fault-tolerant)
        run: |
          node - <<'JS'
          // CJS-friendly imports
          const { HLTV } = require('hltv');
          const fs = require('fs');
          const Papa = require('papaparse');

          // Gentle pacing to avoid Cloudflare
          const sleep = ms => new Promise(r => setTimeout(r, ms));

          // Utils
          const writeJSON = (obj, path) => {
            try { fs.writeFileSync(path, JSON.stringify(obj, null, 2)); }
            catch (e) { console.error('writeJSON error', path, e?.message); }
          };
          const writeCSV = (rows, path) => {
            try {
              const csv = Papa.unparse(rows || [], { quotes: true });
              fs.writeFileSync(path, csv);
            } catch (e) {
              console.error('writeCSV error for', path, e?.message);
              try { fs.writeFileSync(path, ''); } catch {}
            }
          };

          (async () => {
            let ranking = [];
            let teamIds = [];
            let teamDetails = [];
            let playerIds = [];
            let stats = [];

            // 1) Get HLTV Top-100 teams (ranking)
            try {
              // HLTV.getTeamRanking() returns array with { team: { id, name }, place, points, ... }
              const all = await HLTV.getTeamRanking();
              ranking = (all || []).slice(0, 100);
              teamIds = ranking.map(r => r?.team?.id).filter(Boolean);
              writeJSON({ count: teamIds.length, sample: ranking.slice(0,5) }, 'hltv_top100.json');
            } catch (e) {
              console.error('getTeamRanking failed:', e?.message);
              writeJSON({ error: e?.message }, 'hltv_top100.json');
              // If we can't get ranking, bail gracefully with empty artifacts
              writeJSON([], 'hltv_matches_today.json');
              writeCSV([], 'hltv_player_form.csv');
              writeCSV([], 'hltv_projections.csv');
              return;
            }

            // 2) For each team id → get roster (players)
            try {
              for (const id of teamIds) {
                try {
                  const t = await HLTV.getTeam({ id });
                  teamDetails.push({ id, name: t?.name || '', players: t?.players || [] });
                } catch (e) {
                  console.error('getTeam fail', id, e?.message);
                  teamDetails.push({ id, name: '', players: [] });
                }
                await sleep(300);
              }
              writeJSON({ teams: teamDetails.length }, 'hltv_teams_meta.json');
              playerIds = [...new Set(teamDetails.flatMap(t => (t.players || []).map(p => p.id)).filter(Boolean))];
            } catch (e) {
              console.error('Team roster pipeline failed:', e?.message);
            }

            // 3) Player stats (last 60 days) for all unique players seen in Top-100 rosters
            try {
              const todayISO = new Date().toISOString().slice(0,10);
              const sinceISO = new Date(Date.now() - 60*24*3600*1000).toISOString().slice(0,10);

              for (const pid of playerIds) {
                try {
                  const s = await HLTV.getPlayerStats({ id: pid, startDate: sinceISO, endDate: todayISO });
                  stats.push({
                    playerId: pid,
                    nickname: s?.player?.nickname,
                    team:     s?.team?.name,
                    maps:     s?.overview?.mapsPlayed,
                    kpr:      s?.overview?.kpr,            // kills per round
                    hsPct:    s?.overview?.hsPercentage,   // headshot percentage
                    adr:      s?.overview?.adr,
                    rating:   s?.overview?.rating1
                  });
                } catch (e) {
                  console.error('getPlayerStats fail', pid, e?.message);
                }
                await sleep(300);
              }
            } catch (e) {
              console.error('Player stats pipeline failed:', e?.message);
            }

            // Save the raw player form table
            writeCSV(stats, 'hltv_player_form.csv');

            // 4) Conservative projections (CS2 only; independent of UD)
            try {
              const shrink = (rate, n, base, k) => ((n*rate + k*base)/((n+k)||1));
              const leagueKPR = 0.68, leagueHS = 0.46;      // conservative baselines
              const out = [];

              for (const r of stats) {
                const maps = +r.maps || 0;
                const kpr  = +r.kpr  || leagueKPR;
                const hs   = +r.hsPct || leagueHS;

                // Heavier regression when sample is small/new team
                const kprAdj = shrink(kpr, maps, leagueKPR, maps < 25 ? 40 : 25);
                const hsAdj  = shrink(hs,  maps, leagueHS,  maps < 25 ? 60 : 40);

                // Balanced baseline ≈ 50 rounds across Maps 1+2 (MR12)
                const muKills = 50 * kprAdj;

                out.push({
                  player: r.nickname,
                  team:   r.team,
                  maps,
                  kprAdj:  +kprAdj.toFixed(3),
                  hsAdj:   +hsAdj.toFixed(3),
                  projKills: +muKills.toFixed(1),
                  projHS:    +(muKills*hsAdj).toFixed(1)
                });
              }

              writeCSV(out, 'hltv_projections.csv');
              console.log(`Top-100 teams processed. Teams: ${teamIds.length}, Players: ${playerIds.length}, Projections: ${out.length}`);
            } catch (e) {
              console.error('Projection step failed:', e?.message);
              writeCSV([], 'hltv_projections.csv');
            }

            // Maintain compatibility with earlier artifacts
            writeJSON([], 'hltv_matches_today.json');
          })().catch(e => {
            console.error('Top-level error:', e?.message);
            // Always produce artifacts so the job succeeds
            try { fs.writeFileSync('hltv_top100.json', JSON.stringify({ error: e?.message }, null, 2)); } catch {}
            try { fs.writeFileSync('hltv_teams_meta.json', JSON.stringify({ error: e?.message }, null, 2)); } catch {}
            try { fs.writeFileSync('hltv_matches_today.json', JSON.stringify([], null, 2)); } catch {}
            try { fs.writeFileSync('hltv_player_form.csv', ''); } catch {}
            try { fs.writeFileSync('hltv_projections.csv', ''); } catch {}
            process.exitCode = 0;
          });
          JS

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: hltv_edges
          path: |
            hltv_top100.json
            hltv_teams_meta.json
            hltv_matches_today.json
            hltv_player_form.csv
            hltv_projections.csv
          if-no-files-found: warn
