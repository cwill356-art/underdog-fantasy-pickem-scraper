name: HLTV projections from YOUR Underdog CSV
on:
  workflow_dispatch:
    inputs:
      ud_csv_path:
        description: "Path to your Underdog CSV (committed in this repo)"
        required: true
        default: "underdog_props_esports.csv"
      lookback_days:
        description: "HLTV player stats lookback window (days)"
        required: false
        default: "60"
      throttle_ms:
        description: "Delay between HLTV requests (ms)"
        required: false
        default: "350"

jobs:
  run:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Show repo tree (confirm CSV path)
        run: |
          echo "== Repo tree (depth 3) =="
          find . -maxdepth 3 -type f | sed 's|^\./||' | sort

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install deps
        run: npm i hltv papaparse

      - name: Build CS2 projections from your UD file and join edges (with fuzzy mapper)
        env:
          UD_CSV_PATH: ${{ inputs.ud_csv_path }}
          LOOKBACK_DAYS: ${{ inputs.lookback_days }}
          THROTTLE_MS: ${{ inputs.throttle_ms }}
        run: |
          node - <<'JS'
          // ================== Imports ==================
          const { HLTV } = require('hltv');   // official wrapper
          const fs = require('fs');
          const Papa = require('papaparse');

          // ================== Small utils ==================
          const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
          const norm = s => String(s||'')
            .toLowerCase()
            .normalize('NFKD').replace(/[\u0300-\u036f]/g,'') // strip accents
            .replace(/\s+/g,'')
            .replace(/[^a-z0-9_]/g,''); // keep a-z0-9 and underscore

          // Basic Levenshtein distance (no extra deps)
          function lev(a,b){
            a = String(a); b = String(b);
            const m=a.length, n=b.length;
            if(!m) return n; if(!n) return m;
            const dp = Array.from({length:m+1},(_,i)=>Array(n+1).fill(0));
            for(let i=0;i<=m;i++) dp[i][0]=i;
            for(let j=0;j<=n;j++) dp[0][j]=j;
            for(let i=1;i<=m;i++){
              for(let j=1;j<=n;j++){
                const cost = a[i-1]===b[j-1]?0:1;
                dp[i][j]=Math.min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+cost);
              }
            }
            return dp[m][n];
          }
          // Similarity score in [0,1] (1 = exact)
          function sim(a,b){
            if(!a && !b) return 1;
            const L = Math.max(String(a).length, String(b).length) || 1;
            return 1 - (lev(a,b)/L);
          }

          const impliedProb = (dec) => (isFinite(dec) && dec>0 ? 1/dec : 0.526);
          const shrink = (rate, n, base, k) => ((n*rate + k*base) / ((n+k)||1));

          // erf polyfill (CDF)
          function erf(x){
            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x);
            const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;
            const t = 1/(1+p*x);
            const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
            return sign*y;
          }

          const writeCSV = (rows, path) => {
            try {
              const csv = Papa.unparse(rows || [], { quotes: true });
              fs.writeFileSync(path, csv);
            } catch (e) {
              console.error('writeCSV error for', path, e?.message);
              try { fs.writeFileSync(path, ''); } catch {}
            }
          };
          const readCSVauto = (path) => {
            try {
              const txt = fs.readFileSync(path, 'utf8');
              const parsed = Papa.parse(txt, { header: true, skipEmptyLines: true });
              return parsed.data || [];
            } catch (e) {
              console.error('Could not read CSV at', path, e?.message);
              return [];
            }
          };

          async function withRetry(fn, {tries=3, delay=400}={}){
            let lastErr;
            for (let i=0;i<tries;i++){
              try { return await fn(); }
              catch(e){ lastErr = e; await sleep(delay); }
            }
            throw lastErr;
          }

          (async () => {
            const UD_CSV_PATH   = process.env.UD_CSV_PATH || 'underdog_props_esports.csv';
            const LOOKBACK_DAYS = parseInt(process.env.LOOKBACK_DAYS||'60',10);
            const THROTTLE_MS   = parseInt(process.env.THROTTLE_MS  ||'350',10);

            // Conservative baselines
            const leagueKPR = 0.68, leagueHS = 0.46;
            const EXPECTED_ROUNDS = 50; // Maps 1+2 baseline (MR12)

            // Confirm CSV exists
            if (!fs.existsSync(UD_CSV_PATH)) {
              console.error('UD_CSV_PATH not found:', UD_CSV_PATH);
              writeCSV([], 'hl_players_mapped.csv');
              writeCSV([], 'hltv_player_form.csv');
              writeCSV([], 'hltv_projections.csv');
              writeCSV([], 'ud_vs_model_edges.csv');
              writeCSV([], 'hl_players_unmapped.csv');
              return;
            }

            const today = new Date();
            const startDate = new Date(today.getTime() - LOOKBACK_DAYS*24*3600*1000).toISOString().slice(0,10);
            const endDate   = today.toISOString().slice(0,10);

            // ============== 1) Load UD CSV ==============
            const udRaw = readCSVauto(UD_CSV_PATH);
            console.log('UD rows found:', udRaw.length, 'from', UD_CSV_PATH);

            const pickCol = (row, keys) => {
              for (const k of keys) if (row.hasOwnProperty(k) && row[k] != null && row[k] !== '') return row[k];
              return '';
            };

            // Parse schema: player, sport_name, market, side, decimal_price; numeric line from selection_subheader
            const udParsed = udRaw.map(r => {
              const player = String(pickCol(r, ['player','full_name','name','selection_header'])).trim();
              const sport  = String(pickCol(r, ['sport_name','sport'])).trim();
              const market = String(pickCol(r, ['market','stat_name','category'])).trim();
              let line = pickCol(r, ['line']);
              if (!(isFinite(parseFloat(line)))) {
                const ss = String(pickCol(r, ['selection_subheader','display'])).toLowerCase();
                const m = /(\d+(?:\.\d+)?)/.exec(ss);
                line = m ? m[1] : '';
              }
              line = parseFloat(line);
              const side = String(pickCol(r, ['side','choice'])).toLowerCase();
              const dec  = parseFloat(pickCol(r, ['decimal_price','decimalodds','decimal_odds']));
              return { player, sport, market, side, line, dec_odds: isFinite(dec)?dec:1.90 };
            }).filter(x => x.player && x.market);

            // Keep Counter-Strike only and markets we model
            const csRows = udParsed.filter(x => {
              const isCS = String(x.sport||'').toUpperCase() === 'CS';
              const m = x.market.toLowerCase();
              const isMkt = m.includes('kills_on_maps_1_2') || m.includes('headshots_on_maps_1_2');
              return isCS && isMkt && isFinite(x.line);
            });

            if (!csRows.length) {
              console.warn('No Counter-Strike rows to process; writing empty artifacts.');
              writeCSV([], 'hl_players_mapped.csv');
              writeCSV([], 'hltv_player_form.csv');
              writeCSV([], 'hltv_projections.csv');
              writeCSV([], 'ud_vs_model_edges.csv');
              writeCSV([], 'hl_players_unmapped.csv');
              return;
            }
            console.log('CS2 rows to project:', csRows.length);
            console.log('Sample parsed rows:', csRows.slice(0,5));

            // ============== 2) Map UD names -> HLTV IDs (fuzzy) ==============
            // Optional manual overrides: player_aliases.csv (ud_name,hltv_id)
            const manualMap = new Map();
            if (fs.existsSync('player_aliases.csv')) {
              for (const r of readCSVauto('player_aliases.csv')) {
                const nm = norm(r.ud_name);
                const pid = parseInt(r.hltv_id, 10);
                if (nm && Number.isFinite(pid)) manualMap.set(nm, pid);
              }
            }

            // Seed popular aliases (helps out-of-the-box)
            const seeded = {
              'donk': 22729, 'zywoo': 11893, 'monesy': 19230, 'm0nesy': 19230,
              's1mple': 7998, 'b1t': 18987, 'niko': 3741, 'device': 7592, 'blamef': 15165,
              'ropz': 11816, 'rain': 8183, 'broky': 16555, 'karrigan': 429,
              'jabbi': 20347, 'stavn': 16787, 'xertion': 20424, 'frozen': 7187
            };
            for (const [k,v] of Object.entries(seeded)) if (!manualMap.has(k)) manualMap.set(k, v);

            // Hosted directory for broad coverage
            let playersDir = [];
            try {
              const res = await withRetry(() => fetch('https://hltv-api.vercel.app/api/players', { headers: { 'user-agent': 'github-action-hltv-from-ud' }}));
              playersDir = await res.json();
            } catch (e) {
              console.error('Hosted /players fetch failed:', e?.message);
            }
            // Build candidate index
            const pool = (playersDir || []).map(p => {
              const nickname = p.nickname || p.name || '';
              return {
                id: p.id || p.playerId || p._id,
                nickname,
                key: norm(nickname)
              };
            }).filter(x => x.id && x.key);

            function bestCandidates(udName, k=5){
              const key = norm(udName);
              const results = [];
              for (const c of pool) {
                // scores: exact > startsWith/includes > similarity
                let score = 0;
                if (c.key === key) score = 1.0;
                else if (c.key.startsWith(key) || key.startsWith(c.key)) score = 0.95;
                else if (c.key.includes(key) || key.includes(c.key)) score = 0.92;
                else score = 0.80 * sim(key, c.key);
                results.push({ id: c.id, nickname: c.nickname, score });
              }
              results.sort((a,b)=> b.score - a.score);
              return results.slice(0,k);
            }

            const uniquePlayers = [...new Set(csRows.map(x => x.player))];

            const mapped = [];
            const unmapped = [];
            for (const udName of uniquePlayers) {
              const key = norm(udName);

              // 1) manual/seed alias hit
              let hltvId = manualMap.get(key) || null;
              let nickname = null;

              // 2) exact/fuzzy search if needed
              if (!hltvId) {
                const cands = bestCandidates(udName, 5);
                if (cands.length && cands[0].score >= 0.92) {
                  hltvId = cands[0].id;
                  nickname = cands[0].nickname;
                } else {
                  // keep as unresolved with suggestions
                  unmapped.push({
                    ud_name: udName,
                    suggestion_1: cands[0]?.nickname || '',
                    suggestion_1_id: cands[0]?.id || '',
                    suggestion_1_score: cands[0]?.score?.toFixed(3) || '',
                    suggestion_2: cands[1]?.nickname || '',
                    suggestion_2_id: cands[1]?.id || '',
                    suggestion_2_score: cands[1]?.score?.toFixed(3) || '',
                    suggestion_3: cands[2]?.nickname || '',
                    suggestion_3_id: cands[2]?.id || '',
                    suggestion_3_score: cands[2]?.score?.toFixed(3) || '',
                    suggestion_4: cands[3]?.nickname || '',
                    suggestion_4_id: cands[3]?.id || '',
                    suggestion_4_score: cands[3]?.score?.toFixed(3) || '',
                    suggestion_5: cands[4]?.nickname || '',
                    suggestion_5_id: cands[4]?.id || '',
                    suggestion_5_score: cands[4]?.score?.toFixed(3) || '',
                  });
                }
              }

              mapped.push({ ud_name: udName, hltv_id: hltvId || '', nickname: nickname || udName });
            }
            writeCSV(mapped, 'hl_players_mapped.csv');
            writeCSV(unmapped, 'hl_players_unmapped.csv');

            const withIDs = mapped.filter(x => String(x.hltv_id).trim() !== '');
            console.log('Mapped to HLTV IDs:', withIDs.length, '/', mapped.length);
            if (unmapped.length) {
              console.log(`Unmapped players: ${unmapped.length} (see hl_players_unmapped.csv for suggestions)`);
            }

            // ============== 3) Pull HLTV player stats (with retries) ==============
            const stats = [];
            for (const m of withIDs) {
              try {
                const id = parseInt(m.hltv_id, 10);
                if (!Number.isFinite(id)) continue;
                const s = await withRetry(() => HLTV.getPlayerStats({ id, startDate, endDate }), {tries: 3, delay: 500});
                stats.push({
                  playerId: id,
                  nickname: s?.player?.nickname || m.nickname || m.ud_name,
                  team:     s?.team?.name || '',
                  maps:     s?.overview?.mapsPlayed,
                  kpr:      s?.overview?.kpr,
                  hsPct:    s?.overview?.hsPercentage,
                  adr:      s?.overview?.adr,
                  rating:   s?.overview?.rating1
                });
              } catch (e) {
                console.error('getPlayerStats fail', m.hltv_id, m.ud_name, e?.message);
              }
              await sleep(Number.isFinite(THROTTLE_MS) ? THROTTLE_MS : 350);
            }
            writeCSV(stats, 'hltv_player_form.csv');

            // ============== 4) Projections (conservative) ==============
            const pf = new Map(stats.map(r => [norm(r.nickname), r]));
            const projRows = [];
            for (const r of stats) {
              const maps = +r.maps || 0;
              const kpr  = +r.kpr  || leagueKPR;
              const hs   = +r.hsPct || leagueHS;
              const kprAdj = shrink(kpr, maps, leagueKPR, maps < 25 ? 40 : 25);
              const hsAdj  = shrink(hs,  maps, leagueHS,  maps < 25 ? 60 : 40);
              const muKills = EXPECTED_ROUNDS * kprAdj;
              projRows.push({
                player: r.nickname, team: r.team, maps,
                kprAdj: +kprAdj.toFixed(3), hsAdj: +hsAdj.toFixed(3),
                projKills: +muKills.toFixed(1), projHS: +(muKills*hsAdj).toFixed(1)
              });
            }
            writeCSV(projRows, 'hltv_projections.csv');

            // ============== 5) Join vs UD props + probabilities/edges ==============
            function tailProbOver(line, mu, variance) {
              const sigma = Math.sqrt(Math.max(variance, 1e-6));
              const z = (line - mu)/sigma;
              const pOver = 1 - 0.5*(1+erf(z/Math.SQRT2));
              return { pOver, pUnder: 1 - pOver, sigma };
            }

            const outEdges = [];
            for (const u of csRows) {
              const form = pf.get(norm(u.player));
              if (!form || !isFinite(u.line)) continue;

              const maps = +form.maps || 0;
              const kpr  = +form.kpr  || leagueKPR;
              const hs   = +form.hsPct || leagueHS;
              const kprAdj = shrink(kpr, maps, leagueKPR, maps < 25 ? 40 : 25);
              const hsAdj  = shrink(hs,  maps, leagueHS,  maps < 25 ? 60 : 40);
              const muKills = EXPECTED_ROUNDS * kprAdj;

              let mu, variance;
              const mkt = u.market.toLowerCase();
              if (mkt.includes('kills_on_maps_1_2')) {
                mu = muKills;
                variance = EXPECTED_ROUNDS * kprAdj * (1 - kprAdj) + 3.0; // cushion
              } else if (mkt.includes('headshots_on_maps_1_2')) {
                mu = muKills * hsAdj;
                variance = muKills * hsAdj * (1 - hsAdj) + 2.0;          // cushion
              } else {
                continue;
              }

              const { pOver, pUnder, sigma } = tailProbOver(u.line, mu, variance);
              const modelProb = u.side === 'over' ? pOver : pUnder;
              const implied = impliedProb(u.dec_odds);
              const edge = modelProb - implied;

              outEdges.push({
                player: u.player,
                team: form.team || '',
                market: u.market,
                side: u.side,
                ud_line: +u.line.toFixed(1),
                ud_dec: +u.dec_odds,
                our_mu: +mu.toFixed(2),
                our_sigma: +sigma.toFixed(2),
                prob_over: +pOver.toFixed(3),
                prob_under: +pUnder.toFixed(3),
                model_prob: +modelProb.toFixed(3),
                edge: +edge.toFixed(3),
                sample_maps: form.maps
              });
            }

            outEdges.sort((a,b)=> b.edge - a.edge);
            writeCSV(outEdges, 'ud_vs_model_edges.csv');

            console.log(`Done. CS rows: ${csRows.length}, mapped IDs: ${withIDs.length}, HLTV stats: ${stats.length}, edges: ${outEdges.length}`);
          })().catch(err => {
            console.error('Top-level error:', err?.message);
            try { fs.writeFileSync('hl_players_mapped.csv', ''); } catch {}
            try { fs.writeFileSync('hltv_player_form.csv', ''); } catch {}
            try { fs.writeFileSync('hltv_projections.csv', ''); } catch {}
            try { fs.writeFileSync('ud_vs_model_edges.csv', ''); } catch {}
            try { fs.writeFileSync('hl_players_unmapped.csv', ''); } catch {}
            process.exitCode = 0;
          });
          JS

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: hltv_from_ud_edges
          path: |
            ${{ inputs.ud_csv_path }}
            player_aliases.csv
            hl_players_mapped.csv
            hl_players_unmapped.csv
            hltv_player_form.csv
            hltv_projections.csv
            ud_vs_model_edges.csv
          if-no-files-found: warn
