name: HLTV projections (explicit player list + fuzzy + live HLTV search)

on:
  workflow_dispatch:
    inputs:
      ud_csv_path:
        description: "Path to your Underdog CSV (leave blank to auto-detect)"
        required: false
        default: ""
      lookback_days:
        description: "HLTV player stats lookback window (days)"
        required: false
        default: "60"
      throttle_ms:
        description: "Delay between HLTV requests (ms)"
        required: false
        default: "350"

jobs:
  run:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install deps
        run: npm i hltv papaparse

      - name: Build CS2 projections (ALIASES + fuzzy + HLTV search)
        env:
          UD_CSV_PATH: ${{ inputs.ud_csv_path }}
          LOOKBACK_DAYS: ${{ inputs.lookback_days }}
          THROTTLE_MS: ${{ inputs.throttle_ms }}
        run: |
          node - <<'JS'
          const { HLTV } = require('hltv');
          const fs = require('fs');
          const Papa = require('papaparse');

          const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
          const norm = s => String(s||'')
            .toLowerCase()
            .normalize('NFKD').replace(/[\u0300-\u036f]/g,'')
            .replace(/\s+/g,'')
            .replace(/[^a-z0-9_]/g,'');

          // -------------------- FIXED ALIASES --------------------
          const ALIASES = {
            "adron": null, // TODO: HLTV id for ADRON
            "aw": null, // TODO: HLTV id for AW
            "artfr0st": null, // TODO: HLTV id for ArtFr0st
            "belchonokk": null,
            "batuuu": null,
            "brollan": null,
            "clasia": null,
            "cypher": null,
            "callme": null,
            "chop": null,
            "chopper": null,
            "ciocardau": null,
            "closer": null,
            "crunchy": null,
            "cryptic": null,
            "dgl": null,
            "dengzoe": null,
            "drox": null,
            "elfmelk": null,
            "fallen": null,
            "grizz": null,
            "heavygod": null,
            "hext": null,
            "icarus": null,
            "jambo": null,
            "jame": null,
            "jayy2s": null,
            "jimpphat": null,
            "johnsm1th": null,
            "junior": null,
            "krimz": null,
            "kscerato": null,
            "karrigan": 429, // Karrigan
            "spinx": 16949, // Spinx
            "sunpayus": 15858, // SunPayus
            "zywoo": 11893, // ZywOo
            "blamef": 15165, // blameF
            "broky": 16555, // broky
            "donk": 22729, // donk
            "flamez": 20102, // flameZ
            "frozen": 7187, // frozen
            "hunter": 9647, // huNter-
            "rain": 8183, // rain
            "ropz": 11816, // ropz
            "torzsi": 19619, // torzsi
            "xertion": 20424 // xertioN
          };

          // -------------------- HELPERS --------------------
          const impliedProb = (dec) => (isFinite(dec) && dec>0 ? 1/dec : 0.526);
          const shrink = (rate,n,base,k)=>((n*rate+k*base)/((n+k)||1));
          function erf(x){const s=x<0?-1:1;x=Math.abs(x);const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;const t=1/(1+p*x);const y=1-(((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t)*Math.exp(-x*x);return s*y;}

          const writeCSV = (rows, path) => {
            try { const csv = Papa.unparse(rows || [], { quotes: true }); fs.writeFileSync(path, csv); }
            catch (e) { fs.writeFileSync(path, ''); }
          };
          const readCSVauto = (path) => {
            try { const txt = fs.readFileSync(path, 'utf8'); return Papa.parse(txt, { header: true }).data; }
            catch { return []; }
          };

          // -------------------- MAIN --------------------
          (async () => {
            const csvPath = process.env.UD_CSV_PATH || 'underdog_props_esports.csv';
            const LOOKBACK_DAYS = parseInt(process.env.LOOKBACK_DAYS||'60',10);
            const THROTTLE_MS   = parseInt(process.env.THROTTLE_MS||'350',10);
            const leagueKPR = 0.68, leagueHS = 0.46, EXPECTED_ROUNDS = 50;

            if (!fs.existsSync(csvPath)) {
              console.error("CSV not found:", csvPath);
              writeCSV([], 'ud_vs_model_edges.csv');
              return;
            }

            const ud = readCSVauto(csvPath).map(r => ({
              player: r.player?.trim(),
              market: r.market,
              side: r.side,
              line: parseFloat(r.line),
              dec_odds: parseFloat(r.decimal_price)
            })).filter(x=>x.player && x.market && isFinite(x.line));

            const csRows = ud.filter(x=>/kills_on_maps_1_2|headshots_on_maps_1_2/i.test(x.market));
            console.log("CS2 rows:", csRows.length);

            // Map players via ALIASES
            const mapped = csRows.map(r=>{
              const id = Number.isFinite(+ALIASES[norm(r.player)]) ? +ALIASES[norm(r.player)] : null;
              return { ...r, hltv_id:id };
            });

            // Fetch stats
            const today = new Date();
            const startDate = new Date(today.getTime() - LOOKBACK_DAYS*86400000).toISOString().slice(0,10);
            const endDate   = today.toISOString().slice(0,10);
            const stats=[];
            for (const m of mapped.filter(x=>x.hltv_id)) {
              try {
                const s = await HLTV.getPlayerStats({ id:m.hltv_id, startDate, endDate });
                stats.push({
                  playerId:m.hltv_id,
                  nickname:s?.player?.nickname || m.player,
                  team:s?.team?.name||'',
                  maps:s?.overview?.mapsPlayed,
                  kpr:s?.overview?.kpr,
                  hsPct:s?.overview?.hsPercentage,
                  adr:s?.overview?.adr,
                  rating:s?.overview?.rating1
                });
              } catch(e){ console.error("Stats fail for",m.player,e.message); }
              await sleep(THROTTLE_MS);
            }
            writeCSV(stats,'hltv_player_form.csv');

            // Projections + edges
            const pf=new Map(stats.map(r=>[norm(r.nickname),r]));
            const edges=[];
            for(const u of mapped){
              const f=pf.get(norm(u.player)); if(!f) continue;
              const maps=+f.maps||0, kpr=+f.kpr||0.68, hs=+f.hsPct||0.46;
              const kprAdj=shrink(kpr,maps,0.68,maps<25?40:25);
              const hsAdj=shrink(hs,maps,0.46,maps<25?60:40);
              const muKills=EXPECTED_ROUNDS*kprAdj;
              let mu,variance;
              if(u.market.toLowerCase().includes('kills')){mu=muKills;variance=EXPECTED_ROUNDS*kprAdj*(1-kprAdj)+3;}
              else {mu=muKills*hsAdj;variance=muKills*hsAdj*(1-hsAdj)+2;}
              const sigma=Math.sqrt(Math.max(variance,1e-6));
              const z=(u.line-mu)/sigma;
              const pOver=1-0.5*(1+erf(z/Math.SQRT2));
              const modelProb=u.side==='over'?pOver:1-pOver;
              const edge=modelProb-impliedProb(u.dec_odds);
              edges.push({player:u.player,team:f.team,market:u.market,side:u.side,ud_line:u.line,our_mu:+mu.toFixed(2),edge:+edge.toFixed(3)});
            }
            edges.sort((a,b)=>b.edge-a.edge);
            writeCSV(edges,'ud_vs_model_edges.csv');
          })();
          JS

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: hltv_from_ud_edges
          path: |
            ${{ inputs.ud_csv_path }}
            hltv_player_form.csv
            ud_vs_model_edges.csv
          if-no-files-found: warn
