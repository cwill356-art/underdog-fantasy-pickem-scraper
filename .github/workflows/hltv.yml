name: HLTV projections from YOUR Underdog CSV (auto-detect + player mapping)
on:
  workflow_dispatch:
    inputs:
      ud_csv_path:
        description: "Path to your Underdog CSV (leave blank to auto-detect)"
        required: false
        default: ""
      lookback_days:
        description: "HLTV player stats lookback window (days)"
        required: false
        default: "60"
      throttle_ms:
        description: "Delay between HLTV requests (ms)"
        required: false
        default: "350"

jobs:
  run:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install deps
        run: npm i hltv papaparse

      - name: Build CS2 projections (auto-detect CSV, use 'player' column)
        env:
          UD_CSV_PATH: ${{ inputs.ud_csv_path }}
          LOOKBACK_DAYS: ${{ inputs.lookback_days }}
          THROTTLE_MS: ${{ inputs.throttle_ms }}
        run: |
          node - <<'JS'
          // ================== Imports ==================
          const { HLTV } = require('hltv');   // official wrapper
          const fs = require('fs');
          const Papa = require('papaparse');

          // ================== Helpers ==================
          const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
          const norm = s => String(s||'')
            .toLowerCase()
            .normalize('NFKD').replace(/[\u0300-\u036f]/g,'') // strip accents
            .replace(/\s+/g,'')
            .replace(/[^a-z0-9_]/g,''); // keep a-z0-9 and underscore

          // mini-glob over repo without extra deps
          function listFiles(root='.') {
            const out=[];
            function walk(dir, depth=0){
              if (depth>4) return;
              for (const name of fs.readdirSync(dir)) {
                const p = dir + '/' + name;
                const st = fs.statSync(p);
                if (st.isDirectory()) walk(p, depth+1);
                else out.push(p.replace(/^\.\//,''));
              }
            }
            walk('.');
            return out;
          }

          function firstThatMatches(paths, patterns) {
            for (const pat of patterns) {
              const rx = new RegExp(pat.replace(/\*/g,'.*'), 'i');
              const hit = paths.find(p => rx.test(p));
              if (hit) return hit;
            }
            return null;
          }

          const impliedProb = (dec) => (isFinite(dec) && dec>0 ? 1/dec : 0.526);
          const shrink = (rate, n, base, k) => ((n*rate + k*base) / ((n+k)||1));
          function erf(x){ const s=x<0?-1:1; x=Math.abs(x);
            const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;
            const t=1/(1+p*x); const y=1-(((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t)*Math.exp(-x*x); return s*y; }

          const writeCSV = (rows, path) => {
            try { const csv = Papa.unparse(rows || [], { quotes: true }); fs.writeFileSync(path, csv); }
            catch (e) { console.error('writeCSV error for', path, e?.message); try { fs.writeFileSync(path, ''); } catch {} }
          };
          const readCSVauto = (path) => {
            try { const txt = fs.readFileSync(path, 'utf8'); const parsed = Papa.parse(txt, { header: true, skipEmptyLines: true }); return parsed.data || []; }
            catch (e) { console.error('Could not read CSV at', path, e?.message); return []; }
          };
          async function withRetry(fn, {tries=3, delay=400}={}){ let last; for (let i=0;i<tries;i++){ try { return await fn(); } catch(e){ last=e; await sleep(delay); } } throw last; }

          // ================== Main ==================
          (async () => {
            const INPUT_PATH = (process.env.UD_CSV_PATH||'').trim();
            const LOOKBACK_DAYS = parseInt(process.env.LOOKBACK_DAYS||'60',10);
            const THROTTLE_MS   = parseInt(process.env.THROTTLE_MS  ||'350',10);

            // Conservative baselines
            const leagueKPR = 0.68, leagueHS = 0.46;
            const EXPECTED_ROUNDS = 50; // Maps 1+2 baseline (MR12)

            // 0) Resolve CSV path (auto-detect if blank or missing)
            let csvPath = INPUT_PATH;
            if (!csvPath || !fs.existsSync(csvPath)) {
              const files = listFiles('.');
              csvPath = firstThatMatches(files, [
                'underdog_props_esports*.csv',
                '*underdog*props*esports*.csv',
                '*underdog*esports*.csv',
                '*underdog*props*.csv'
              ]) || '';
              if (!csvPath) {
                console.error('Could not find UD CSV. Searched common patterns. Provide ud_csv_path when running the workflow.');
                writeCSV([], 'hl_players_mapped.csv');
                writeCSV([], 'hl_players_unmapped.csv');
                writeCSV([], 'hltv_player_form.csv');
                writeCSV([], 'hltv_projections.csv');
                writeCSV([], 'ud_vs_model_edges.csv');
                return;
              }
            }
            console.log('Using UD CSV:', csvPath);

            const today = new Date();
            const startDate = new Date(today.getTime() - LOOKBACK_DAYS*24*3600*1000).toISOString().slice(0,10);
            const endDate   = today.toISOString().slice(0,10);

            // 1) Load UD CSV (player is the source of truth)
            const ud = readCSVauto(csvPath);
            console.log('UD rows found:', ud.length, 'from', csvPath);

            const pick = (row, keys) => { for (const k of keys) if (row.hasOwnProperty(k) && row[k] != null && row[k] !== '') return row[k]; return ''; };

            const rows = ud.map(r => {
              const player = String(pick(r, ['player'])).trim();      // <-- use 'player' column only
              const sport  = String(pick(r, ['sport_name','sport'])).trim();
              const market = String(pick(r, ['market'])).trim();
              let line = pick(r, ['line']);
              if (!(isFinite(parseFloat(line)))) {
                const ss = String(pick(r, ['selection_subheader','display'])).toLowerCase();
                const m = /(\d+(?:\.\d+)?)/.exec(ss);
                line = m ? m[1] : '';
              }
              line = parseFloat(line);
              const side = String(pick(r, ['side'])).toLowerCase();
              const dec  = parseFloat(pick(r, ['decimal_price']));
              return { player, sport, market, side, line, dec_odds: isFinite(dec)?dec:1.90 };
            }).filter(x => x.player && x.market);

            // Filter: CS only + markets we support
            const csRows = rows.filter(x => {
              const isCS = String(x.sport||'').toUpperCase() === 'CS' || /kills_on_maps_1_2|headshots_on_maps_1_2/i.test(x.market);
              const m = x.market.toLowerCase();
              const isMkt = m.includes('kills_on_maps_1_2') || m.includes('headshots_on_maps_1_2');
              return isCS && isMkt && isFinite(x.line);
            });

            console.log('CS2 rows to project:', csRows.length);
            console.log('Sample parsed (first 8):', csRows.slice(0,8).map(r => ({player:r.player, market:r.market, line:r.line, dec:r.dec_odds})));

            if (!csRows.length) {
              console.warn('No Counter-Strike rows to process; writing empty artifacts.');
              writeCSV([], 'hl_players_mapped.csv');
              writeCSV([], 'hl_players_unmapped.csv');
              writeCSV([], 'hltv_player_form.csv');
              writeCSV([], 'hltv_projections.csv');
              writeCSV([], 'ud_vs_model_edges.csv');
              return;
            }

            // 2) Map UD 'player' -> HLTV IDs (nickname or real name)
            const manualMap = new Map();
            if (fs.existsSync('player_aliases.csv')) {
              for (const r of readCSVauto('player_aliases.csv')) {
                const nm = norm(r.ud_name);
                const pid = parseInt(r.hltv_id, 10);
                if (nm && Number.isFinite(pid)) manualMap.set(nm, pid);
              }
            }

            // seed a few popular aliases
            const seeded = { 'donk': 22729, 'zywoo': 11893, 'm0nesy': 19230, 'monesy': 19230, 'blamef': 15165, 's1mple': 7998, 'niko': 3741 };
            for (const [k,v] of Object.entries(seeded)) if (!manualMap.has(k)) manualMap.set(k, v);

            // Pull HLTV player directory
            let playersDir = [];
            try {
              const res = await withRetry(() => fetch('https://hltv-api.vercel.app/api/players', { headers: { 'user-agent': 'hltv-csv-mapper' }}));
              playersDir = await res.json();
            } catch (e) {
              console.error('Hosted /players fetch failed:', e?.message);
            }

            // Build candidate pool of nickname + real name
            const pool = (playersDir || []).flatMap(p => {
              const id = p.id || p.playerId || p._id;
              const nickname = p.nickname || '';
              const realname = p.name || '';
              const arr = [];
              if (id && nickname) arr.push({ id, shown: nickname, key: norm(nickname) });
              if (id && realname) arr.push({ id, shown: realname, key: norm(realname) });
              return arr;
            });

            // Exact index for super-fast hits
            const exact = new Map();
            for (const c of pool) if (c.key && c.id && !exact.has(c.key)) exact.set(c.key, c);

            // fuzzy helpers
            function lev(a,b){
              a = String(a); b = String(b);
              const m=a.length, n=b.length;
              if(!m) return n; if(!n) return m;
              const dp = Array.from({length:m+1},(_,i)=>Array(n+1).fill(0));
              for(let i=0;i<=m;i++) dp[i][0]=i;
              for(let j=0;j<=n;j++) dp[0][j]=j;
              for(let i=1;i<=m;i++){
                for(let j=1;j<=n;j++){
                  const cost = a[i-1]===b[j-1]?0:1;
                  dp[i][j]=Math.min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+cost);
                }
              }
              return dp[m][n];
            }
            const sim = (a,b) => { const L=Math.max(String(a).length,String(b).length)||1; return 1 - (lev(a,b)/L); };

            function bestCandidates(udName, k=5){
              const key = norm(udName);
              const list = [];
              const e = exact.get(key);
              if (e) return [{ id: e.id, nickname: e.shown, score: 1.0 }];
              for (const c of pool) {
                let score = 0;
                if (c.key.startsWith(key) || key.startsWith(c.key)) score = 0.96;
                else if (c.key.includes(key) || key.includes(c.key)) score = 0.93;
                else score = 0.80 * sim(key, c.key);
                list.push({ id: c.id, nickname: c.shown, score });
              }
              list.sort((a,b)=> b.score - a.score);
              return list.slice(0,k);
            }

            const uniquePlayers = [...new Set(csRows.map(x => x.player))];
            const mapped = [], unmapped = [];
            for (const udName of uniquePlayers) {
              const key = norm(udName);
              let hltvId = manualMap.get(key) || null;
              let nickname = null;
              if (!hltvId) {
                const cands = bestCandidates(udName, 5);
                if (cands.length && cands[0].score >= 0.93) {
                  hltvId = cands[0].id; nickname = cands[0].nickname;
                } else {
                  unmapped.push({
                    ud_name: udName,
                    suggestion_1: cands[0]?.nickname || '', suggestion_1_id: cands[0]?.id || '', suggestion_1_score: cands[0]?.score?.toFixed(3) || '',
                    suggestion_2: cands[1]?.nickname || '', suggestion_2_id: cands[1]?.id || '', suggestion_2_score: cands[1]?.score?.toFixed(3) || '',
                    suggestion_3: cands[2]?.nickname || '', suggestion_3_id: cands[2]?.id || '', suggestion_3_score: cands[2]?.score?.toFixed(3) || '',
                    suggestion_4: cands[3]?.nickname || '', suggestion_4_id: cands[3]?.id || '', suggestion_4_score: cands[3]?.score?.toFixed(3) || '',
                    suggestion_5: cands[4]?.nickname || '', suggestion_5_id: cands[4]?.id || '', suggestion_5_score: cands[4]?.score?.toFixed(3) || '',
                  });
                }
              }
              mapped.push({ ud_name: udName, hltv_id: hltvId || '', nickname: nickname || udName });
            }
            writeCSV(mapped, 'hl_players_mapped.csv');
            writeCSV(unmapped, 'hl_players_unmapped.csv');

            const withIDs = mapped.filter(x => String(x.hltv_id).trim() !== '');
            console.log('Mapped to HLTV IDs:', withIDs.length, '/', mapped.length);
            if (unmapped.length) console.log(`Unmapped players: ${unmapped.length} (see hl_players_unmapped.csv)`);

            // 3) HLTV stats
            const today = new Date();
            const startDate = new Date(today.getTime() - LOOKBACK_DAYS*24*3600*1000).toISOString().slice(0,10);
            const endDate   = today.toISOString().slice(0,10);

            const stats = [];
            for (const m of withIDs) {
              try {
                const id = parseInt(m.hltv_id, 10);
                if (!Number.isFinite(id)) continue;
                const s = await withRetry(() => HLTV.getPlayerStats({ id, startDate, endDate }), {tries: 3, delay: 500});
                stats.push({
                  playerId: id,
                  nickname: s?.player?.nickname || m.nickname || m.ud_name,
                  team:     s?.team?.name || '',
                  maps:     s?.overview?.mapsPlayed,
                  kpr:      s?.overview?.kpr,
                  hsPct:    s?.overview?.hsPercentage,
                  adr:      s?.overview?.adr,
                  rating:   s?.overview?.rating1
                });
              } catch (e) {
                console.error('getPlayerStats fail', m.hltv_id, m.ud_name, e?.message);
              }
              await sleep(Number.isFinite(THROTTLE_MS) ? THROTTLE_MS : 350);
            }
            writeCSV(stats, 'hltv_player_form.csv');

            // 4) Projections
            const pf = new Map(stats.map(r => [norm(r.nickname), r]));
            const proj = [];
            for (const r of stats) {
              const maps = +r.maps || 0;
              const kpr  = +r.kpr  || leagueKPR;
              const hs   = +r.hsPct || leagueHS;
              const kprAdj = shrink(kpr, maps, leagueKPR, maps < 25 ? 40 : 25);
              const hsAdj  = shrink(hs,  maps, leagueHS,  maps < 25 ? 60 : 40);
              const muKills = EXPECTED_ROUNDS * kprAdj;
              proj.push({ player: r.nickname, team: r.team, maps, kprAdj:+kprAdj.toFixed(3), hsAdj:+hsAdj.toFixed(3), projKills:+muKills.toFixed(1), projHS:+(muKills*hsAdj).toFixed(1) });
            }
            writeCSV(proj, 'hltv_projections.csv');

            // 5) Edges
            function tailProbOver(line, mu, variance) {
              const sigma = Math.sqrt(Math.max(variance, 1e-6));
              const z = (line - mu)/sigma;
              const pOver = 1 - 0.5*(1+erf(z/Math.SQRT2));
              return { pOver, pUnder: 1 - pOver, sigma };
            }

            const edges = [];
            for (const u of csRows) {
              const form = pf.get(norm(u.player));
              if (!form || !isFinite(u.line)) continue;

              const maps = +form.maps || 0;
              const kpr  = +form.kpr  || leagueKPR;
              const hs   = +form.hsPct || leagueHS;
              const kprAdj = shrink(kpr, maps, leagueKPR, maps < 25 ? 40 : 25);
              const hsAdj  = shrink(hs,  maps, leagueHS,  maps < 25 ? 60 : 40);
              const muKills = EXPECTED_ROUNDS * kprAdj;

              let mu, variance;
              const mkt = u.market.toLowerCase();
              if (mkt.includes('kills_on_maps_1_2')) {
                mu = muKills;
                variance = EXPECTED_ROUNDS * kprAdj * (1 - kprAdj) + 3.0;
              } else if (mkt.includes('headshots_on_maps_1_2')) {
                mu = muKills * hsAdj;
                variance = muKills * hsAdj * (1 - hsAdj) + 2.0;
              } else continue;

              const { pOver, pUnder, sigma } = tailProbOver(u.line, mu, variance);
              const modelProb = u.side === 'over' ? pOver : pUnder;
              const implied = impliedProb(u.dec_odds);
              const edge = modelProb - implied;

              edges.push({
                player: u.player, team: form.team || '', market: u.market, side: u.side,
                ud_line: +u.line.toFixed(1), ud_dec: +u.dec_odds,
                our_mu: +mu.toFixed(2), our_sigma: +sigma.toFixed(2),
                prob_over: +pOver.toFixed(3), prob_under: +pUnder.toFixed(3),
                model_prob: +modelProb.toFixed(3), edge: +edge.toFixed(3),
                sample_maps: form.maps
              });
            }

            edges.sort((a,b)=> b.edge - a.edge);
            writeCSV(edges, 'ud_vs_model_edges.csv');

            console.log(`Done. CS rows: ${csRows.length}, mapped IDs: ${withIDs.length}, HLTV stats: ${stats.length}, edges: ${edges.length}`);
          })().catch(err => {
            console.error('Top-level error:', err?.message);
            try { fs.writeFileSync('hl_players_mapped.csv', ''); } catch {}
            try { fs.writeFileSync('hl_players_unmapped.csv', ''); } catch {}
            try { fs.writeFileSync('hltv_player_form.csv', ''); } catch {}
            try { fs.writeFileSync('hltv_projections.csv', ''); } catch {}
            try { fs.writeFileSync('ud_vs_model_edges.csv', ''); } catch {}
            process.exitCode = 0;
          });
          JS

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: hltv_from_ud_edges
          path: |
            ${{ inputs.ud_csv_path }}
            hl_players_mapped.csv
            hl_players_unmapped.csv
            hltv_player_form.csv
            hltv_projections.csv
            ud_vs_model_edges.csv
          if-no-files-found: warn
